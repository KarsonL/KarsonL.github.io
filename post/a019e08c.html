<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java 基础 | Karson.L</title><meta name="keywords" content="Java"><meta name="author" content="Karson.L"><meta name="copyright" content="Karson.L"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、Java基础面向对象面向对象和面向过程的区别   1）从概念上来说。  面向过程：字面意义上就是面向的是过程，对于给定任务，考虑先做什么、在做什么、最后做什么，然后用函数把这些步骤一步一步地实现，在使用的时候一一调用则可。 面向对象：字面意义上就是面向的是对象，也就是把参与任务的有关事物 分解成各个对象，用一种结构将其定义出来。但是建立对象的目的也不是为了完成一个个步骤，而是为了描述这个事物在">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 基础">
<meta property="og:url" content="https://karsonl.github.io/post/a019e08c.html">
<meta property="og:site_name" content="Karson.L">
<meta property="og:description" content="一、Java基础面向对象面向对象和面向过程的区别   1）从概念上来说。  面向过程：字面意义上就是面向的是过程，对于给定任务，考虑先做什么、在做什么、最后做什么，然后用函数把这些步骤一步一步地实现，在使用的时候一一调用则可。 面向对象：字面意义上就是面向的是对象，也就是把参与任务的有关事物 分解成各个对象，用一种结构将其定义出来。但是建立对象的目的也不是为了完成一个个步骤，而是为了描述这个事物在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.7bb201f8780350e0cef5df437eefd820?rik=M60StjPxJ91nEQ&riu=http%3a%2f%2fallvectorlogo.com%2fimg%2f2016%2f11%2fjava-logo.png&ehk=ngyH0QOJ2mDCmXqKwUheTYinnnw4LIzLTFRZAJl96bo%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2022-07-14T14:00:00.000Z">
<meta property="article:modified_time" content="2022-07-24T13:36:27.082Z">
<meta property="article:author" content="Karson.L">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.7bb201f8780350e0cef5df437eefd820?rik=M60StjPxJ91nEQ&riu=http%3a%2f%2fallvectorlogo.com%2fimg%2f2016%2f11%2fjava-logo.png&ehk=ngyH0QOJ2mDCmXqKwUheTYinnnw4LIzLTFRZAJl96bo%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/./imgs/logo/logo-x-outfull.png"><link rel="canonical" href="https://karsonl.github.io/post/a019e08c"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-24 21:36:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./imgs/logo/logo-x-outfull.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.7bb201f8780350e0cef5df437eefd820?rik=M60StjPxJ91nEQ&amp;riu=http%3a%2f%2fallvectorlogo.com%2fimg%2f2016%2f11%2fjava-logo.png&amp;ehk=ngyH0QOJ2mDCmXqKwUheTYinnnw4LIzLTFRZAJl96bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Karson.L</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-07-14T14:00:00.000Z" title="发表于 2022-07-14 22:00:00">2022-07-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a><strong>一、Java基础</strong></h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><strong>面向对象</strong></h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a><strong>面向对象和面向过程的区别</strong></h3><ul>
<li><ul>
<li><ul>
<li><p>1）从<strong>概念</strong>上来说。</p>
<ul>
<li><strong>面向过程</strong>：字面意义上就是面向的是过程，对于给定任务，考虑先做什么、在做什么、最后做什么，然后<strong>用函数把这些步骤一步一步地实现</strong>，在使用的时候一一调用则可。</li>
<li><strong>面向对象</strong>：字面意义上就是面向的是对象，也就是<strong>把参与任务的有关事物</strong> <strong><code>分解成各个对象</code></strong>，用一种结构将其定义出来。但是建立对象的<strong>目的也不是为了完成一个个步骤</strong>，而是为了<strong>描述这个事物在完成任务的过程中所发生的行为。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ul>
<li>2）从<strong>性能</strong>上来说。由于<strong>面向对象</strong>，需要进行<strong>实例化对象</strong>、<strong>分配内存</strong>等操作，开销较大，因此<strong>性能上比面向过程的低</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>3）从<strong>可用性</strong>来说。<strong>面向对象</strong>有<strong>封装、继承、多态</strong>的特性，所以<strong>易维护、易复用、易扩展</strong>，可以设计出低耦合的系统。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><ul>
<li>把对象<strong>属性私有化</strong>，同时提供可以被外界访问的的<strong>属性和方法</strong>。这样能<strong>隐藏</strong>对象的<strong>具体实现细节</strong>，对外仅提供<strong>公共访问</strong>方式便于使用，<strong>提高代码的安全性</strong>。<strong>（属性私有化）</strong></li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><ul>
<li><ul>
<li><ul>
<li><p>使用<strong>已存在的类</strong>作为<strong>基础</strong>建立<strong>新类</strong>，<strong>新类中</strong>可以<strong>增加新</strong>的数据或新的功能，也可以<strong>用父类的功能</strong>。<strong>继承</strong>可以提高<strong>代码复用性</strong>，是<strong>多态</strong>的前提。</p>
</li>
<li><p><strong>特性：</strong></p>
</li>
<li><ul>
<li>子类拥有父类<strong>所有</strong>的属性和方法（包括私有属性和方法）。但是<strong>无法访问</strong>父类中的<strong>私有属性</strong>和方法，仅仅只是拥有。<strong>（拥有全部属性和方法，但不能访问私有属性和方法）</strong></li>
<li>子类可以拥有自己的属性和方法。（<strong>可扩展</strong>）</li>
<li>子类可以用自己的方式实现父类中的方法，也就是<strong>重写</strong>。<strong>（可重写）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3></li>
<li><ul>
<li><ul>
<li>所谓<strong>多态</strong>就是指（<mark>程序中定义的<strong>引⽤变量</strong>所指向的<strong>具体类型）</strong></mark>和（通过该引⽤变量发出的<strong>⽅法调⽤）</strong>在编程时并<strong>不确定</strong>，⽽是在<strong><code>程序运行期间</code></strong>才确定。</li>
<li>==即⼀个引⽤变量到底会<strong>指向</strong>哪个类的<strong>实例对象</strong>，该引⽤变量发出的<strong>⽅法调⽤</strong>到底是<strong>哪个类</strong>中实现的⽅法，必须在由<strong>程序运行期间</strong>才能决定。==（父类 var = new 子类； var.fun() 可能是子类的方法，也可能是父类的方法）</li>
<li>在 Java 中有两种形式可以实现多态：<strong>继承</strong>（多个⼦类对同⼀⽅法的<strong>重写</strong>）和<strong>接口</strong>（实现接口并<strong>覆盖</strong>接口中同⼀⽅法）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a><strong>重载和重写的区别</strong></h2><ul>
<li><ul>
<li><ul>
<li><strong>重载：同一个类</strong>中，对<strong>同一个方法</strong>的不同实现方式。<strong>要求：方法名</strong>相<strong>同</strong>，<strong>形参列表不同</strong>（包括<strong>参数数量</strong>、<strong>类型</strong>、<strong>（类型）顺序</strong>）。<strong>返回类型</strong>和<strong>访问修饰符</strong>可以<strong>不同</strong>。</li>
<li><strong>重写：子类对父类中同一方法</strong>的不同实现方式。<strong>要求：方法名相同</strong>，<strong>形参列表相同</strong>。<strong>返回类型**</strong>小于等于<strong>父类。</strong>抛出异常范围<strong>**小于等于</strong>父类。<strong>访问修饰符范围**</strong>大于等于<strong>父类。</strong>（两同两小一大）**</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a><strong>接口和抽象类的区别</strong></h2><ul>
<li><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a><strong>相同点：</strong></h3></li>
<li><ul>
<li><ul>
<li><ul>
<li>1、都不能被<strong>实例化</strong>，只能被其他类<strong>继承或实现</strong>；</li>
<li>2、接口的实现类或抽象类的子类<strong>只有实现</strong>了其中的<strong>抽象方法</strong>后才能被<strong>实例化</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a><strong>不同点：</strong></h3></li>
<li><ul>
<li><ul>
<li><ul>
<li><strong>定义：接口</strong>使用<strong>interface</strong>定义，使用<strong>implement实现</strong>。<strong>抽象类</strong>使用<strong>abstract class</strong>定义，使用<strong>extend</strong>进行<strong>继承</strong>。</li>
<li><strong>变量</strong>：<strong>接口</strong>中的变量默认都是<strong>public final static修饰的</strong>，必须<strong>赋初值</strong>，也就是都是<strong>常量</strong>。<strong>抽象类</strong>中默认是<strong>default</strong>，可以在子类中被<strong>重新定义，赋值</strong>。</li>
<li><strong>方法</strong>：<strong>接口</strong>中的方法<strong>全是抽象方法</strong>。<strong>抽象类</strong>中可以有构造方法，实现了的方法，但是<strong>不一定**</strong>有抽象方法，但是有抽象方法的类一定是抽象类<strong>。抽象类中的抽象方法</strong>不能被private、static、synchronized修饰。**</li>
<li><strong>继承</strong>：一个类可以实现<strong>多个接口</strong>，但是仅能<strong>继承一个类</strong>。</li>
<li><strong>本质：接口</strong>强调<strong>特定功能的实现</strong>；<strong>抽象类</strong>强调<strong>所属关系。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h2><ul>
<li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>JAVA反射</strong>是在<strong>运行状态</strong>中，对于<strong>任意一个类</strong>都能够知道这个类的<strong>所有属性和方法</strong>；对于<strong>任意</strong> <strong>对象</strong>都能够<strong>调用</strong>它的<strong>任意方法和属性</strong>；这种<strong>动态获取信息</strong>以及<strong>动态调用对象方法</strong>的功能称为<strong>反射。</strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3></li>
<li><ol>
<li><ul>
<li><strong>优点：1）</strong>可以在<strong>运行期间</strong>进行<strong>类型的判断</strong>；2）<strong>动态加载类</strong>；3）<strong>动态</strong>获取<strong>类的实例对象</strong>；4）提高代码<strong>灵活度和复用率</strong>。</li>
</ul>
</li>
<li><ul>
<li><strong>缺点</strong>：1）使用反射<strong>性能较低</strong>，需要<strong>解析字节码</strong>，将内存中的对象进行解析。2）<strong>反射允许</strong>代码<strong>执行</strong>一些正常情况下<strong>不被允许的操作</strong>（如<strong>访问私有</strong>属性和方法），降低了代码的<strong>安全性</strong>和破坏了<strong>封装性</strong>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><h3 id="获取反射的方式（3种）"><a href="#获取反射的方式（3种）" class="headerlink" title="获取反射的方式（3种）"></a>获取反射的方式（3种）</h3><p>1）<strong>Class.forName</strong>(“类的路径”)； 2）<strong>类名.class；</strong>  3）<strong>对象 名.getClass()</strong> ； </p>
</li>
<li><h3 id="反射的使用场景（JDBC、Spring）"><a href="#反射的使用场景（JDBC、Spring）" class="headerlink" title="反射的使用场景（JDBC、Spring）"></a><strong>反射的使用场景（JDBC、Spring）</strong></h3></li>
<li><ul>
<li><ul>
<li>反射是<strong>框架设计</strong>的灵魂。</li>
<li>①我们在使用<strong>JDBC**</strong>连接数据库<strong>时使用</strong>Class.forName()<strong>通过反射加载数据库的</strong>驱动程序**；</li>
<li>②<strong>Spring框架</strong>也用到很多反射机制，最经典的就是<strong>xml的配置模式</strong>。</li>
<li><strong>（扩展）</strong>Spring 通过 XML 配置模式<strong>装载 Bean</strong> 的过程：</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>\1) 将所有<strong>XML</strong>或Properties配置文件<strong>加载入内存</strong>中； </li>
<li>\2) Java类<strong>解析xml</strong>或properties内容，得到对应实体类的<strong>字节码字符串</strong>以及<strong>相关属性</strong>信息； </li>
<li>\3) 使用<strong>反射机制</strong>，根据<strong>字符串</strong>获得某个类的<strong>Class实例；</strong></li>
<li>\4) <strong>动态配置实例属性</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a><strong>String类</strong></h2><ul>
<li><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a><strong>字符型常量和字符串常量的区别</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>形式：字符常量</strong>是<strong>单引号</strong>引起的<strong>一个字符</strong>，<strong>字符串常量</strong>是<strong>双引号</strong>引起的<strong>若干个字符</strong>；</li>
<li><strong>含义: 字符常量</strong>相当于<strong>整型值(ASCII值)，**</strong>可参加表达式运算<strong>**；字符串常量</strong>代表<strong>地址值**</strong>(<strong>该字符串在</strong>内存中**存放位置)；</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="== 和equals的区别"></a><strong>== 和equals的区别</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>==</strong>判断两个对象<strong>是否是同一个对象</strong>。（基本数据类型比较的是值，引用类型比较的是内存地址）</li>
<li><strong>equals</strong> 判断两个对象<strong>是否相等</strong>。如果<strong>没有重写</strong>，则和<strong>==</strong>是一样的。</li>
<li>equals<strong>如果重写了</strong>，则根据重写后的规则进行比较。比如<strong>String</strong>重写了equals，<strong>比较的是两个字符串的值。</strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="为什么重写equals后，hashcode-也要重写"><a href="#为什么重写equals后，hashcode-也要重写" class="headerlink" title="为什么重写equals后，hashcode()也要重写"></a><strong>为什么重写equals后，hashcode()也要重写</strong></h3></li>
<li><ul>
<li><ul>
<li>equals判断的是<strong>两个对象是否相等</strong>。若<strong>两个对象相等</strong>，则他们的<strong>hashcode</strong>一定是<strong>相同的</strong>，<strong>equals</strong>也应该返回<strong>true</strong>；</li>
<li>但是<strong>hashcode</strong> 相同的两个对象，他们也不一定相等。若<strong>hashcode不同</strong>，则<strong>equals</strong>也必须为<strong>false</strong>；</li>
<li><strong>hashcode()默认</strong>是对<strong>堆</strong>上的对象产生<strong>独特的值</strong>（计算方式：内存地址+哈希算法）。<strong>若不重写</strong>，则该class的两个对象<strong>无论如何都不会相等</strong>，也就是两个对象的得到的<strong>hashcode一定不会相同。</strong></li>
<li>但是<strong>重写的equals</strong>可能会将他们判定为<strong>true</strong>，这就<strong>违背</strong>了<strong>对象相同的原则</strong>。</li>
<li>因此若<strong>重写了equals</strong>，则<strong>hashcode也必须要重写</strong>。（案列：HashSet中，先进行hashcode判断，相同然后再执行equals。如不重写，则无法去重）</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="String、Stringbuilder、Stringbuffer的区别"><a href="#String、Stringbuilder、Stringbuffer的区别" class="headerlink" title="String、Stringbuilder、Stringbuffer的区别"></a><strong>String、Stringbuilder、Stringbuffer的区别</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>String：</strong>用<strong>字符数组</strong>保存字符串，不可变，可理解为<strong>常量</strong>，线程安全。<strong>（不可变，线程安全）</strong></li>
<li><strong>StringBuffer</strong>：继承自<strong>AbstractStringBuilder类</strong>，也是使用字符数组来保存字符串，对象可变。并且其对方法或调用方法<strong>加了**</strong>同步锁<strong>，因此是线程安全的。</strong>（可变、线程安全）**</li>
<li><strong>StringBuilder</strong>：继承自<strong>AbstractStringBuilder类</strong>，也是使用字符数组来保存字符串，对象可变。但是<strong>没有对方法加同步锁</strong>，所以线程不安全。<strong>（可变、线程不安全）</strong></li>
<li><strong>String类</strong>每次变化都是<strong>新生成一个对象</strong>。<strong>StringBuilder和StringBuffer</strong>则是对对象本身操作，<strong>不会生成新对象。（新对象 / 原地修改）</strong></li>
<li><strong>StringBuilder</strong>比<strong>StringBuffer**</strong>性能<strong>更</strong>高<strong>，但是</strong>线程不安全<strong>。因此，</strong>单线程<strong>用</strong>StringBuilder。多线程<strong>用</strong>StringBuffer。**</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a><strong>IO流</strong></h2><ul>
<li><h3 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a><strong>BIO、NIO、AIO的区别</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>BIO（Blocking I/O）：**</strong>同步阻塞<strong>I/O模型，数据读写必须</strong>阻塞在一个线程内<strong>等待完成。简单，适用于</strong>低负载、低并发<strong>的应用，可提升</strong>开发速率和更好的维护性**；</li>
<li><strong>NIO（New I/O、Non-Blocking I/O）：**</strong>同步非阻塞<strong>的I/O模型。支持</strong>面向<strong><strong>缓冲</strong></strong>，基于<strong>**通道</strong>的I/O操作方法，适用于<strong>高负载、高并发</strong>的（网络）应用。</li>
<li><strong>AIO（Asynchronous I/O）：</strong>是NIO 的<strong>改进版 NIO 2</strong>，<strong>异步非阻塞</strong>I/O模型。基于<strong>事件和回调机制</strong>实现，应用操作之后会<strong>直接返回</strong>，不会堵塞在那里，当<strong>后台</strong>处理完成，操作系统会通知相应的<strong>线程</strong>进行<strong>后续操作。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a><strong>自动装箱和自动拆箱</strong></h2><ul>
<li><ul>
<li><ul>
<li><strong>Java为每一个基本数据类型提供了一个对应的包装类。</strong></li>
<li><strong>装箱</strong>：将基本数据类型⽤它们对应的引⽤类型包装起来；</li>
<li><strong>拆箱：</strong>将包装类型转换为基本数据类型；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a><strong>为什么Java中只有值传递</strong></h2><ul>
<li><ul>
<li><ul>
<li>参数的传递一般有两种方式：<strong>值传递**</strong>和<strong>**引用传递</strong></li>
<li><strong>值传递（pass by value）</strong>是指在调用方法时将实际参数<strong>复制</strong>一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数。</li>
<li><strong>引用传递（pass by reference**</strong>）<strong>是指在调用方法时将实际参数的</strong>地址**直接传递到方法中，那么在方法中对参数所进行的修改，将影响到实际参数。</li>
<li><strong>Java总是按值传递</strong>。方法得到的是所有参数的<strong>拷贝</strong>，因此，方法<strong>不能修改</strong>传递给它的任何参数变量的内容。当传递的是引用变量时，方法也不能修改该引用变量所指向的对象，但是能修改该对象的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h2><ul>
<li><h3 id="Error-和-Exception的区别"><a href="#Error-和-Exception的区别" class="headerlink" title="Error 和 Exception的区别"></a><strong>Error 和 Exception的区别</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>Error：</strong>是程序<strong>无法处理</strong>的错误。如虚拟机运行错误，内存不足错误、栈溢出错误等。此类错误发生，<strong>JVM会终止线程</strong>。</li>
<li><strong>Exception：</strong>是<strong>程序本身可以处理</strong>的异常，可以通过<strong>catch</strong>来捕获并处理。<strong>Exception又可分为运行时异常和编译时异常。</strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="运行时异常-和-编译时异常"><a href="#运行时异常-和-编译时异常" class="headerlink" title="运行时异常 和 编译时异常"></a><strong>运行时异常 和 编译时异常</strong></h3></li>
<li><ul>
<li><ul>
<li><strong>运行时异常：</strong>是<strong>RuntimeException</strong>及其子类声明的异常，表示JVM在<strong>运行期间</strong>可能出现的异常。如<strong>空指针异常，数组下标越界异常</strong>等。此类异常属于<strong>不受检异常</strong>，由<strong>程序逻辑错</strong>误引起，<strong>可以捕获处理也可不处理</strong>。当发生运行时异常时，<strong>JVM会自动捕获并抛出</strong>，此类异常绝大数情况是<strong>代码本身有问题</strong>，应从逻辑上解决、改进代码。</li>
<li><strong>编译时异常：</strong>是Exception 中<strong>除</strong> RuntimeException 及其子类之外的异常，表示在<strong>编译时</strong>就会被检查的异常。比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常）。此类异常属于<strong>受检异常</strong>，<strong>Java 编译器会检查</strong>。程序出现此类异常，必须进行处理。要么<strong>throws</strong>声明抛出，要么<strong>try-catch</strong>捕获处理，<strong>否则不能通过编译</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="finally-中-的-return"><a href="#finally-中-的-return" class="headerlink" title="finally 中 的 return"></a><strong>finally 中 的 return</strong></h3></li>
<li><ul>
<li><ul>
<li>try-catch-finally是处理异常的一种方式。无论是否捕获或处理异常，finally中的代码都会被执行。</li>
<li>若try或catch中有return语句时，则<strong>finally中的代码会在return去前执行</strong>。若finally中也有return语句，则会<strong>提前返回</strong>。</li>
<li>若在try或catch中<strong>要return一个变量</strong>，则在finally中进行了修改，若为<strong>基本数据类型</strong>，则<strong>不会改变原返回值</strong>。若是<strong>引用类型</strong>，也不会改变其引用的对象，但是<strong>可以改变里面的内容</strong>。（和<strong>值传递</strong>一样）</li>
<li>若finally中也要返回，则会提前返回finally中要return的值。（可理解为方法的返回，不会改变传入前的变量的值，但是可以返回）</li>
<li>（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pcheng/p/10968841.html">JAVA中try、catch、finally带return的执行顺序总结 - PC君 - 博客园 (cnblogs.com)</a>）（可将finally理解为一个方法，参数只会值传递，但是返回是自由的。）</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="throw-和-throws的区别"><a href="#throw-和-throws的区别" class="headerlink" title="throw 和 throws的区别"></a><strong>throw 和 throws的区别</strong></h3></li>
<li><ul>
<li><ul>
<li>异常处理除了捕获和处理异常，还包括<strong>声明异常</strong>和<strong>拋出异常</strong>，可通过 <strong>throws</strong>在<strong>方法上声明要拋出的异常列表</strong>，或在<strong>方法内</strong>通过 <strong>throw</strong> <strong>拋出异常</strong>。</li>
<li><strong>throw</strong> 用在<strong>方法内部</strong>，抛出方法或代码块中的异常，只能<strong>抛出一种异常</strong>，<strong>受检异常</strong>和<strong>非受检异常</strong>都可被抛出。</li>
<li><strong>throws</strong> 用在<strong>方法声明</strong>上，用来<strong>标识</strong>可能<strong>抛出的异常列表，</strong>可以声明<strong>抛出多个异常。</strong></li>
<li>一个方法用 <strong>throws</strong> 标识了可能<strong>抛出的异常列表</strong>，则<strong>调用</strong>该方法的方法中必须包含<strong>处理这些异常</strong>的代码，<strong>否则</strong>也要在方法声明上中用 <strong>throws 声明相应异常。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二、Java集合框架"><a href="#二、Java集合框架" class="headerlink" title="二、Java集合框架"></a><strong>二、Java集合框架</strong></h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><ul>
<li><h3 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a><strong>ArrayList 和 LinkedList 的区别</strong></h3></li>
<li><ul>
<li><ul>
<li>1.ArrayList的底层数据结构是<strong>数组</strong>，所以<strong>查找遍历快</strong>，<strong>增删慢</strong>。</li>
<li>2.ArrayList可随着元素的增长而自动扩容，正常扩容的话，每次扩容到<strong>原来的1.5倍</strong>。</li>
<li>3.ArrayList的线程是<strong>不安全的</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="ArrayList的扩容机制（-50-）"><a href="#ArrayList的扩容机制（-50-）" class="headerlink" title="ArrayList的扩容机制（+50%）"></a><strong>ArrayList的扩容机制（+50%）</strong></h3></li>
</ul>
<p>int newCapacity = oldCapacity +  (oldCapacity &gt;&gt; 1); //也就是将原来的容量增加<strong>一半</strong>，而不是<strong>一倍</strong>。</p>
<ul>
<li><p>扩容可分为<strong>两种情况：</strong></p>
</li>
<li><ul>
<li><p>第<strong>一</strong>种情况，当<strong>ArrayList的容量为0</strong>时，此时添加元素的话，需要扩容，三种构造方法创建的ArrayList在扩容时略有不同：</p>
</li>
<li><ul>
<li>1.<strong>无参构造</strong>，创建ArrayList后容量为0，添加第一个元素后，容量变为<strong>10</strong>，此后若需要扩容，则正常扩容。</li>
<li>2.<strong>传容量构造</strong>，当参数为0时，创建ArrayList后容量为0，添加第一个元素后，<strong>容量为1</strong>，此时ArrayList是满的，下次添加元素时需正常扩容。</li>
<li>3.<strong>传列表构造</strong>，当列表为<strong>空</strong>时，创建ArrayList后容量为0，添加第一个元素后，<strong>容量为1</strong>，此时ArrayList是满的，下次添加元素时需正常扩容。</li>
</ul>
</li>
<li><p>第<strong>二</strong>种情况，当<strong>ArrayList的容量大于0</strong>，并且ArrayList是满的时，此时添加元素的话，进行正常扩容，每次扩容到原来的<strong>1.5倍</strong>。</p>
</li>
<li><ul>
<li>如果扩大1.5倍后还不够，则直接将其扩大至minCapacity大小。</li>
<li>判断minCapacity是否大于MAX_ARRAY_SIZE，如果大于则直接扩大值<strong>Integer最大值</strong>，否则返回MAX_ARRAY_SIZE。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><ul>
<li><h3 id="HashSet的底层实现"><a href="#HashSet的底层实现" class="headerlink" title="HashSet的底层实现"></a><strong>HashSet的底层实现</strong></h3></li>
<li><h3 id="TreeSet的底层实现"><a href="#TreeSet的底层实现" class="headerlink" title="TreeSet的底层实现"></a><strong>TreeSet的底层实现</strong></h3></li>
<li><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a><strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></h3></li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h2><ul>
<li><h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a><strong>HashMap的底层实现</strong></h3></li>
<li><ul>
<li><ul>
<li><p>数组+链表（jdk1.8后，链表达到一定条件会变成红黑树）</p>
</li>
<li><p>HashMap添加元素时，用key的hashcode重新hash计算当前对象元素在数组中的下标。(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); //<strong>右移16位</strong>然后再<strong>异或</strong>是为了增加扰动，减少hash冲突</p>
</li>
<li><p>若hash值相同：则</p>
</li>
<li><ul>
<li>若key相同（使用equals判断），则覆盖原始值；</li>
<li>若key不相同（发生了hash冲突），则将key-value放入到链表中；</li>
<li><strong>jdk8**</strong>后：若数组长度大于<strong><strong>64</strong></strong>，且链表长度大于<strong><strong>8</strong></strong>时，则链表会转换为<strong><strong>红黑树</strong></strong>。**</li>
</ul>
</li>
<li><p>获取值时，根据key的hash值找到对应的数组下标，若挂着一个链表，则顺着链表一个个比较key，直到找到相同的key，获取对应的值。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>HashMap jdk1.7 和 jdk1.8的对比</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li><p><strong>底层：</strong>jdk8引入了<strong>红黑树</strong>，当链表长度过长时会转换成红黑树，<strong>减少搜索时间。</strong></p>
</li>
<li><p><strong>hash()计算方式：jdk7</strong>：4次位运算+5次异或；<strong>jdk8：</strong>1次位运算+1次异或（见上）；</p>
</li>
<li><p><strong>数据插入方式（链表）：jdk7为头插入，</strong>新数据插入到链表的<strong>头结点；而jdk8为尾插入，</strong>直接将数据插入到<strong>链表尾部。</strong></p>
</li>
<li><p><strong>（扩展）为什么要换成尾插入？（死链问题</strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1e9cf0ac07f4">老生常谈，HashMap的死循环 - 简书 (jianshu.com)</a><strong>）</strong></p>
</li>
<li><ul>
<li>JDK1.7中扩容时，每个元素的rehash之后，都会插入到新数组对应索引的链表头，所以这就导致原链表顺序为A-&gt;B-&gt;C，扩容之后，rehash之后的链表可能为C-&gt;B-&gt;A，元素的顺序发生了变化。在并发场景下，扩容时可能会出现<strong>循环链表</strong>的情况。而JDK1.8从头插入改成尾插入元素的顺序不变，避免出现循环链表的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>为什么HashMap计算hash值时将高16位和低16位异或能减少冲突？</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li>HashMap将hash值<strong>对数组长度取余</strong>，得到数组的下标。为了<strong>减少hash冲突</strong>，hash值的数据<strong>分布应该尽量平均</strong>。</li>
<li>若直接使用key的<strong>hashCode</strong>作为hash值进行<strong>取余操作</strong>，则参与运算的只有hashCode的<strong>低位</strong>，<strong>高位没起任何作用</strong>，发生hash碰撞的<strong>概率较大</strong>。所以<strong>优化思路</strong>是<strong>让hashCode取值**</strong>高位<strong>**也参与运算。</strong></li>
<li>hashCode是一个<strong>int型变量</strong>，为<strong>32位</strong>，所以HashMap将其<strong>右移16位</strong>，刚好<strong>将高位移至低位</strong>，再将其和原来的hashCode进行<strong>异或，</strong>得到的hash值就包含了<strong>高位和低位的信息</strong>，再对数组长度取余时，数据分布会更加均匀，这样就能减小hash碰撞的概率，也就是会减少冲突。</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>HashMap的长度为什么是2的幂次方</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li>HashMap的长度设置为2的幂次方，是为了<strong>方便进行位运算，提高计算效率。</strong></li>
<li>因为HashMap中<strong>计算数组下标</strong>是将hash值对数组长度进行<strong>取余</strong>。当数组长度为2的幂次方时，<strong>取余操作相当于是将</strong> <strong>hash值</strong> <strong>和</strong> <strong>数组长度-1</strong> <strong>后的值进行**</strong>与<strong>**操作</strong>（hash%n = hash&amp;(n-1)），这样能大大提高计算效率。</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>HashMap的扩容机制（+100%）</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li><p>HashMap在<strong>对象创建**</strong>时<strong>不会</strong>初始化<strong>数组，而是在</strong>第一次put<strong>的时候才会在</strong>resize()方法<strong>里面进行</strong>初始化，指定数组容量。<strong>**（创建时什么都没干，在resze()里初始化）</strong></p>
</li>
<li><p>若创建使用的是<strong>空参构造器</strong>，则初始化时会将数组容量指定为<strong>默认值16</strong>。若<strong>指定了容量</strong>进行构造，则会找到一个<strong>不小于指定容量的2的幂次方</strong>作为<strong>阈值</strong>，然后在<strong>第一次put</strong>时令数组<strong>容量等于这个阈值。</strong></p>
</li>
<li><p>之后，当<strong>数组元素超过**</strong>阈值<strong>后，就会进行</strong>扩容<strong>。将数组</strong>容量和阈值<strong>都变为原来的</strong>两倍<strong>。</strong>（扩容两倍）**</p>
</li>
<li><p>因为HashMap为了提高计算数组下标的速度，会将<strong>HashMap的长度设置为2的幂次方</strong>，所以扩容时直接增加一倍，这样变化后的<strong>数组长度</strong>还是<strong>2的幂次方不变。</strong></p>
</li>
<li><p><strong>（扩展）jdk7的扩容：</strong></p>
</li>
<li><ul>
<li>在hashmap对象创建时，若使用<strong>空参构造器</strong>，则以<strong>默认容量值</strong>初始化数组。内部数组是<strong>空数组。**</strong>（创建即指定容量）**</li>
<li>若使用<strong>有参构造器</strong>，则根据参数确定<strong>容量、负载因子、阈值</strong>等。</li>
<li><strong>第一次put</strong>时会初始化数组，其容量变为<strong>不小于指定容量的2的幂数</strong>。然后根据<strong>负载因子</strong>确定<strong>阈值</strong>。</li>
<li>当元素数量超过阈值时，就会进行<strong>扩容</strong>。将数组<strong>容量和阈值</strong>都变为原来的<strong>两倍</strong>。<strong>（扩容两倍）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>扩展：红黑树的实现</strong></li>
<li><strong>fail-fast（快速失败） 和 fail-safe （安全失败）的区别？**</strong>（遍历时修改，不允许 vs 允许）**</li>
</ol>
</li>
<li><ul>
<li><ul>
<li><strong>fail-fast</strong> 是<strong>Java集合</strong>类中的一种<strong>错误机制**</strong>。当<strong>使用</strong>迭代器<strong>对</strong>集合<strong>进行</strong>遍历时<strong>，一旦发现</strong>集合的结构<strong>被</strong>修改<strong>了</strong>（增和删）<strong>，会立刻抛出</strong>ConcurrentModificationException异常（并发修改异常）<strong>导致</strong>遍历失败**。</li>
<li><strong>fail-safe 则允许</strong>对<strong>集合</strong>的<strong>结构</strong>进行<strong>修改</strong>，不会报错<strong>。</strong>因为<strong>fail-safe</strong>在修改集合时会将集合<strong>复制</strong>一份<strong>，</strong>然后<strong>在复制的集合上进行修改**</strong>，<strong>修改完后使用</strong>新集合<strong><strong>替代</strong></strong>原来的集合。**</li>
<li>java.util 包下的集合类都是快速失败机制的，如HashMap 和 ArrayList类。</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>HashMap 和 HashTable的区别</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li>HashMap:引入了红黑树；非线程安全；允许保存<strong>一个null键和null值</strong>；容量默认16，扩容为2n，容量为2的幂次方；计算hash先右移再异或，减少冲突；</li>
<li>HashTable: 数组+链表；<strong>synchronized同步锁</strong>保证<strong>线程安全；</strong>不允许有null键值对；；容量默认11，扩容为2n+1；直接使用key  的 hashcode;</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>ConcurrentHashMap的底层实现，锁的实现</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li><p><strong>HashMap：</strong>没有锁，非线程安全</p>
</li>
<li><p><strong>HashTable：</strong>使用<strong>synchronized同步锁</strong>锁住整个map，线程要访问其中的数组必须拿到锁，保证了数据安全，但是效率也很低。</p>
</li>
<li><p><strong>ConcurrentHashMap（jdk7）：</strong></p>
</li>
<li><ul>
<li><strong>底层实现</strong>：<strong>Segment数组 + HashEntry数组 + 链表</strong>。Segment结构是<strong>数组和链表</strong>结构，包含一个 <strong>HashEntry 数组</strong>，每个 HashEntry 是一个<strong>链表元素</strong>。</li>
<li><strong>锁：</strong>每个 Segment 守护着一个HashEntry数组的元素，当对 HashEntry 数组修改时，必须先获得对应 <strong>Segment锁</strong>，Segment 锁是<strong>ReentrantLock（可重入锁）</strong>。</li>
<li>将数据分段存储，给<strong>每段数据配一个锁</strong>，当一个线程占用锁访问其中一段数据时，这段数据不能被其他线程访问，但是<strong>其他段数据是可以被其他线程访问的</strong>，效率较高。</li>
</ul>
</li>
<li><p><strong>ConcurrentHashMap（jdk8）：</strong></p>
</li>
<li><ul>
<li><strong>底层实现：Node数组 + 链表 / 红黑树</strong>。数组里存储的是<strong>Node节点</strong>，也就是<strong>链表的头节点</strong>。当链表长度超过设定条件时，就会变成红黑树，数组里存储的也是树的根节点。（和HashMap一样）</li>
<li><strong>锁：</strong>jdk8抛弃了分段锁，而是使用 <strong>CAS（乐观锁）+synchronized（同步锁）</strong> 来保证并发安全。<strong>synchronized</strong>只锁住当前<strong>链表或红黑树的根节点</strong>，只要不发生hash冲突，那就不会发生并发，效率更高。</li>
<li>在<strong>put()</strong>时，若没有发生<strong>hash冲突</strong>，则使用<strong>CAS乐观锁</strong> 进行插入，否则就需要加<strong>synchronized同步锁</strong>来保证线程安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ol>
<li><strong>在 JDK 1.8 中，ConcurrentHashMap 为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？</strong></li>
</ol>
</li>
<li><p><strong>锁粒度</strong>降低了，提高效率；</p>
</li>
<li>官方对<strong>synchronized</strong>进行了<strong>优化和升级</strong>，使得synchronized使用起来更加<strong>灵活</strong>；</li>
<li><p>在<strong>大数据量</strong>的操作下，对<strong>基于API</strong>的<strong>ReentractLock</strong>进行操作会有更大的<strong>内存开销</strong>；</p>
</li>
<li><ol>
<li><strong>ConcurrentHashMap 的并发度是什么？</strong></li>
</ol>
</li>
<li><ul>
<li><ul>
<li>程序运行时能够<strong>同时更新 ConccurentHashMap</strong> 且<strong>不产生锁竞争的最大线程数</strong>。默认为 <strong>16</strong>，可以在构造函数中设置。</li>
<li>当用户<strong>设置并发度</strong>时，ConcurrentHashMap 会使用<strong>不小于</strong>该值的<strong>2的幂次方</strong>作为<strong>实际并发度</strong>（假如用户设置并发度为17，实际并发度则为32）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><strong>List、Set、Map的区别</strong></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://karsonl.github.io">Karson.L</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://karsonl.github.io/post/a019e08c.html">https://karsonl.github.io/post/a019e08c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://karsonl.github.io" target="_blank">Karson.L</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.7bb201f8780350e0cef5df437eefd820?rik=M60StjPxJ91nEQ&amp;riu=http%3a%2f%2fallvectorlogo.com%2fimg%2f2016%2f11%2fjava-logo.png&amp;ehk=ngyH0QOJ2mDCmXqKwUheTYinnnw4LIzLTFRZAJl96bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/./imgs/reward/wechat-pay.jpg" target="_blank"><img class="post-qr-code-img" src="/./imgs/reward/wechat-pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/post/2fb5b272.html"><img class="prev-cover" src="https://pic2.zhimg.com/v2-fbb3053df1257ed2a675c6c4182fbdae_720w.jpg?source=172ae18b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Elasticsearch 常见面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./imgs/logo/logo-x-outfull.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Karson.L</div><div class="author-info__description">小小程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KarsonL"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/KarsonL" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1246737796@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">一、Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">接口和抽象类的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">不同点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.4.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%883%E7%A7%8D%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">获取反射的方式（3种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88JDBC%E3%80%81Spring%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">反射的使用场景（JDBC、Spring）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.</span> <span class="toc-text">字符型常量和字符串常量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.</span> <span class="toc-text">&#x3D;&#x3D; 和equals的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E5%90%8E%EF%BC%8Chashcode-%E4%B9%9F%E8%A6%81%E9%87%8D%E5%86%99"><span class="toc-number">1.5.3.</span> <span class="toc-text">为什么重写equals后，hashcode()也要重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81Stringbuilder%E3%80%81Stringbuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.4.</span> <span class="toc-text">String、Stringbuilder、Stringbuffer的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">1.6.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">BIO、NIO、AIO的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="toc-number">1.7.</span> <span class="toc-text">自动装箱和自动拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.8.</span> <span class="toc-text">为什么Java中只有值传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-%E5%92%8C-Exception%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.1.</span> <span class="toc-text">Error 和 Exception的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-%E5%92%8C-%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.9.2.</span> <span class="toc-text">运行时异常 和 编译时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally-%E4%B8%AD-%E7%9A%84-return"><span class="toc-number">1.9.3.</span> <span class="toc-text">finally 中 的 return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw-%E5%92%8C-throws%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.4.</span> <span class="toc-text">throw 和 throws的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">二、Java集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.1.</span> <span class="toc-text">ArrayList 和 LinkedList 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%88-50-%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">ArrayList的扩容机制（+50%）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">2.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">HashSet的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">TreeSet的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">2.2.3.</span> <span class="toc-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">2.3.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">HashMap的底层实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/a019e08c.html" title="Java 基础"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.7bb201f8780350e0cef5df437eefd820?rik=M60StjPxJ91nEQ&amp;riu=http%3a%2f%2fallvectorlogo.com%2fimg%2f2016%2f11%2fjava-logo.png&amp;ehk=ngyH0QOJ2mDCmXqKwUheTYinnnw4LIzLTFRZAJl96bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java 基础"/></a><div class="content"><a class="title" href="/post/a019e08c.html" title="Java 基础">Java 基础</a><time datetime="2022-07-14T14:00:00.000Z" title="发表于 2022-07-14 22:00:00">2022-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2fb5b272.html" title="Elasticsearch 常见面试题"><img src="https://pic2.zhimg.com/v2-fbb3053df1257ed2a675c6c4182fbdae_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Elasticsearch 常见面试题"/></a><div class="content"><a class="title" href="/post/2fb5b272.html" title="Elasticsearch 常见面试题">Elasticsearch 常见面试题</a><time datetime="2022-07-12T13:05:20.000Z" title="发表于 2022-07-12 21:05:20">2022-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/49e48040.html" title="Elasticsearch 与 Spring Data 整合"><img src="https://pic2.zhimg.com/v2-fbb3053df1257ed2a675c6c4182fbdae_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Elasticsearch 与 Spring Data 整合"/></a><div class="content"><a class="title" href="/post/49e48040.html" title="Elasticsearch 与 Spring Data 整合">Elasticsearch 与 Spring Data 整合</a><time datetime="2022-07-12T11:25:20.000Z" title="发表于 2022-07-12 19:25:20">2022-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/869ff926.html" title="Elasticsearch 基础"><img src="https://pic2.zhimg.com/v2-fbb3053df1257ed2a675c6c4182fbdae_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Elasticsearch 基础"/></a><div class="content"><a class="title" href="/post/869ff926.html" title="Elasticsearch 基础">Elasticsearch 基础</a><time datetime="2022-07-12T10:30:30.000Z" title="发表于 2022-07-12 18:30:30">2022-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/560fed86.html" title="Docker 应用部署"><img src="/imgs/docker/docker.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker 应用部署"/></a><div class="content"><a class="title" href="/post/560fed86.html" title="Docker 应用部署">Docker 应用部署</a><time datetime="2022-06-18T13:43:12.000Z" title="发表于 2022-06-18 21:43:12">2022-06-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.7bb201f8780350e0cef5df437eefd820?rik=M60StjPxJ91nEQ&amp;riu=http%3a%2f%2fallvectorlogo.com%2fimg%2f2016%2f11%2fjava-logo.png&amp;ehk=ngyH0QOJ2mDCmXqKwUheTYinnnw4LIzLTFRZAJl96bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Karson.L</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>